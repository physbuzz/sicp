<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>notes-ch4-2.md</title>
    <!-- MathJax for LaTeX support -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']]
            }
        };
    </script>
    <style>
        /* Pygments Syntax Highlighting */
        pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */

        /* Base CSS from markdown_styles.py */
        
        /* Basic reset and fonts */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            padding: 0;
            background-color: #f8f9fa;
        }

        /* Navigation styling */
        .nav {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid #e1e4e8;
        }

        .nav span {
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .nav .activenav {
            background-color: #f1f8ff;
        }

        .nav .activenav a {
            color: #0366d6;
            text-decoration: none;
        }

        .nav .activenav a:hover {
            text-decoration: underline;
        }

        .nav .inactivenav {
            color: #959da5;
            background-color: #f6f8fa;
        }

        /* Center column layout */
        .container {
            max-width: 800px;
            margin: 2rem auto;
            background-color: white;
            padding: 2rem 3rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Typography */
        h1 {
            font-size: 2.2rem;
            margin-bottom: 1.5rem;
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem;
            color: #34495e;
        }

        h3 {
            font-size: 1.5rem;
            margin: 1.8rem 0 1rem;
            color: #34495e;
        }

        h4 {
            font-size: 1.3rem;
            margin: 1.5rem 0 0.8rem;
            color: #34495e;
        }

        h5 {
            font-size: 1.1rem;
            margin: 1.2rem 0 0.8rem;
            color: #34495e;
        }

        /* Table of Contents styling */
        .table-of-contents {
            margin: 0 0 0;
            line-height: 1;
        }

        .toc-list {
            margin: 0;
            padding-left: 20px;
        }

        .toc-list li {
            margin-bottom: 2px;
        }
        .toc-list ul {
            margin-bottom: 2px;
        }

        .exercise-list {
            margin: 0;
            padding-left: 0;
            font-size: 0.95em;
            display: inline;
        }

        .exercise-container {
            display: inline-block;
            margin-top: 2px;
            line-height: 1.2;
        }

        .toc-exercises {
            font-style: italic;
            color: #555;
        }

        .exercise-list a {
            text-decoration: none;
            color: #2070b0;
            margin-right: 0;
        }

        .exercise-list a:hover {
            text-decoration: underline;
        }

        .exercise-list span:not(:last-child):after {
            content: ", ";
            color: #777;
            margin-right: 0;
        }

        /* Blockquote styling */
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            padding: 0 1rem;
            margin: 1rem 0 1.5rem;
            background-color: #f6f8fa;
            border-radius: 0 3px 3px 0;
        }

        blockquote p {
            padding: 0.8rem 0;
        }

        blockquote p:first-child {
            margin-top: 0;
        }

        blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Solution styling */
        h5:has(+p:contains("Solution")) {
            margin-bottom: 0;
        }

        h5:has(+p:contains("Solution")) + p {
            font-weight: bold;
            color: #3c8dbc;
            border-left: 3px solid #3c8dbc;
            padding-left: 0.8rem;
            margin: 0.5rem 0 1rem;
        }

        p {
            margin-bottom: 1rem;
        }

        /* List styling */
        ul, ol {
            margin-bottom: 1rem;
            padding-left: 2.5rem;
        }

        ul li, ol li {
            margin-bottom: 0.5rem;
        }

        /* Code blocks */
        .code-box {
            background-color: #f6f8fa;
            border-radius: 6px;
            overflow: hidden;
            margin: 1rem 0 1.5rem;
            border: 1px solid #e1e4e8;
        }

        .code-header {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.75rem;
            color: #6a737d;
            padding: 0.3rem 0 0rem 0.3rem;
            border-bottom: 1px solid #e1e4e8;
            background-color: #fafbfc;
        }

        .code-header a {
            color: #6a737d;
            text-decoration: none;
        }

        .code-header a:hover {
            text-decoration: underline;
            color: #0366d6;
        }

        /* Standalone code blocks (triple backticks) */
        .codehilite {
            background-color: #f6f8fa;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0 1.5rem;
            border: 1px solid #e1e4e8;
        }

        /* When inside a code-box, remove default styling */
        .code-box .codehilite {
            margin: 0;
            padding: 0;
            border: none;
            border-radius: 0;
        }

        /* Adjust padding for code blocks inside code-box */
        .code-box .codehilite pre {
            padding: 0.2rem 0 0.3rem 0.3rem;
            overflow-x: auto;
            margin: 0;
        }

        /* Normal padding for standalone code blocks */
        .codehilite pre {
            padding: 1rem;
            overflow-x: auto;
            margin: 0;
        }

        .code-output {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.75rem;
            color: #6a737d;
            padding: 0.2rem 0 0.3rem 0.3rem;
            border-top: 1px solid #e1e4e8;
            background-color: #fafbfc;
        }
        .code-output span {
            color: #de37cc;
        }

        .code-output pre {
            margin: 0;
            white-space: pre-wrap;
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
        }
        /* --- Styles for Collapsible Code Blocks --- */
        .collapsible-code {
            border: none; /* Remove default border from details */
            margin-top: 0; /* Adjust spacing if needed */
            margin-bottom: 0; /* Adjust spacing if needed */
        }

        .code-summary {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.75rem;
            color: #6a737d;
            padding: 0.5rem 0.8rem; /* Adjusted padding */
            border-bottom: 1px solid #e1e4e8;
            background-color: #fafbfc;
            cursor: pointer;
            list-style: none; /* Hide default marker */
            display: block; /* Make it block level */
            border-radius: 6px 6px 0 0; /* Round top corners like header */
            position: relative; /* For positioning the marker */
            transition: background-color 0.1s ease-in-out;
        }

        .code-summary:hover {
            background-color: #f1f3f5; /* Slight hover effect */
        }

        /* Add custom marker */
        .code-summary::before {
            content: '►'; /* Collapsed marker */
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.6em;
            color: #6a737d;
            margin-right: 0.5rem;
            transition: transform 0.2s ease-in-out;
        }

        .collapsible-code[open] > .code-summary::before {
            transform: translateY(-50%) rotate(90deg); /* Expanded marker */
        }

        .collapsible-code[open] > .code-summary {
             border-bottom: 1px solid #e1e4e8; /* Ensure border shows when open */
             border-radius: 6px 6px 0 0; /* Keep top rounding when open */
        }

        /* Adjust summary content positioning relative to marker */
        .code-summary a {
            margin-left: 1.2rem; /* Space for the marker */
            color: #6a737d;
            text-decoration: none;
        }
        .code-summary a:hover {
            text-decoration: underline;
            color: #0366d6;
        }

        /* New style for the expand hint */
        .expand-hint {
            font-style: italic;
            font-size: 0.85em;
            color: #888;
            margin-left: 0.5rem;
        }

        /* Ensure content inside details has appropriate spacing/styling */
        .collapsible-code > .codehilite {
            margin: 0;
            border-radius: 0 0 6px 6px; /* Round bottom corners */
            border: none; /* Remove border from codehilite itself */
            border-top: none; /* Remove top border */
        }

        /* Since code output is now outside the details element,
           we need to adjust its styling */
        .collapsible-code + .code-output {
            border-radius: 0 0 6px 6px; /* Round bottom corners */
            margin-top: 0; /* Remove gap */
            border-top: 1px solid #e1e4e8;
        }

        /* Ensure code output has proper border when outside details */
        .code-box > .code-output {
            border-top: 1px solid #e1e4e8;
        }

        .collapsible-code > .run-racket {
             margin-left: 1rem; /* Indent run button */
             margin-bottom: 1rem; /* Add bottom margin */
        }
        /* --- End Collapsible Styles --- */

        code {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.9em;
            padding: 0.2em 0.4em;
            background-color: #f6f8fa;
            border-radius: 3px;
        }

        .codehilite code {
            padding: 0;
            background-color: transparent;
        }

        /* Links */
        a {
            color: #0366d6;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Run button */
        .run-racket {
            display: inline-block;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.4rem 0.8rem;
            background-color: #3c8dbc;
            color: white;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .run-racket:hover {
            background-color: #367fa9;
            text-decoration: none;
        }

        /* Make LaTeX display nicely */
        .MathJax {
            overflow-x: auto;
            overflow-y: hidden;
        }
    
    </style>
</head>
<body>
    <div class="container">
        <div class="nav">
    <span class="activenav"><a href="notes-ch4-1.html">← Previous</a></span>
    <span class="activenav"><a href="../index.html">↑ Up</a></span>
    <span class="activenav"><a href="notes-ch4-3.html">Next →</a></span>
</div>

<p><a href="https://sarabander.github.io/sicp/html/4_002e2.xhtml#g_t4_002e2">HTML Book Chapter 4.2 Link</a></p>
<p><div class="table-of-contents">
<h2>Directory</h2>
<ul class="toc-list">
<ul>
<li><a href="#section-42">Section 4.2</a></li>
<ul>
<li><a href="#notes">Notes</a></li>
<li><a href="#exercises" class="toc-exercises">Exercises</a>
<div class="exercise-container">(
<span class="exercise-list">
<span><a href="#exercise-425">Exercise 4.25</a></span>
<span><a href="#exercise-426">Exercise 4.26</a></span>
<span><a href="#exercise-427">Exercise 4.27</a></span>
<span><a href="#exercise-428">Exercise 4.28</a></span>
<span><a href="#exercise-429">Exercise 4.29</a></span>
<span><a href="#exercise-430">Exercise 4.30</a></span>
<span><a href="#exercise-431">Exercise 4.31</a></span>
<span><a href="#exercise-432">Exercise 4.32</a></span>
<span><a href="#exercise-433">Exercise 4.33</a></span>
<span><a href="#exercise-434">Exercise 4.34</a></span>
</span>)
</div></li>
</ul>
</ul>
</ul>
</div></p>
<h2 id="section-42">Section 4.2</h2>
<h3 id="notes">Notes</h3>
<h3 id="exercises">Exercises</h3>
<h4 id="exercise-425">Exercise 4.25</h4>
<p>Suppose that (in ordinary
applicative-order Scheme) we define <code>unless</code> as shown above and then
define <code>factorial</code> in terms of <code>unless</code> as</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="w">          </span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<p>What happens if we attempt to evaluate <code>(factorial 5)</code>?  Will our
definitions work in a normal-order language?</p>
<h5>Solution</h5>
<h4 id="exercise-426">Exercise 4.26</h4>
<p>Ben Bitdiddle and Alyssa
P. Hacker disagree over the importance of lazy evaluation for implementing
things such as <code>unless</code>.  Ben points out that it's possible to implement
<code>unless</code> in applicative order as a special form.  Alyssa counters that, if
one did that, <code>unless</code> would be merely syntax, not a procedure that could
be used in conjunction with higher-order procedures.  Fill in the details on
both sides of the argument.  Show how to implement <code>unless</code> as a derived
expression (like <code>cond</code> or <code>let</code>), and give an example of a situation
where it might be useful to have <code>unless</code> available as a procedure, rather
than as a special form.</p>
<h5>Solution</h5>
<h4 id="exercise-427">Exercise 4.27</h4>
<p>Suppose we type in the following
definitions to the lazy evaluator:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</code></pre></div>

<p>Give the missing values in the following sequence of interactions, and explain
your answers.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span>

<span class="c1">;;; L-Eval input:</span>
<span class="nb">count</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">⟨@var</span><span class="p">{</span><span class="n">response</span><span class="p">}</span><span class="n">⟩</span>

<span class="c1">;;; L-Eval input:</span>
<span class="n">w</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">⟨@var</span><span class="p">{</span><span class="n">response</span><span class="p">}</span><span class="n">⟩</span>

<span class="c1">;;; L-Eval input:</span>
<span class="nb">count</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">⟨@var</span><span class="p">{</span><span class="n">response</span><span class="p">}</span><span class="n">⟩</span>
</code></pre></div>

<h5>Solution</h5>
<h4 id="exercise-428">Exercise 4.28</h4>
<p><code>Eval</code> uses
<code>actual-value</code> rather than <code>eval</code> to evaluate the operator before
passing it to <code>apply</code>, in order to force the value of the operator.  Give
an example that demonstrates the need for this forcing.</p>
<h5>Solution</h5>
<h4 id="exercise-429">Exercise 4.29</h4>
<p>Exhibit a program that you would
expect to run much more slowly without memoization than with memoization.
Also, consider the following interaction, where the <code>id</code> procedure is
defined as in Exercise 4.27 and <code>count</code> starts at 0:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="c1">;;; L-Eval input:</span>
<span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">⟨@var</span><span class="p">{</span><span class="n">response</span><span class="p">}</span><span class="n">⟩</span>

<span class="c1">;;; L-Eval input:</span>
<span class="nb">count</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">⟨@var</span><span class="p">{</span><span class="n">response</span><span class="p">}</span><span class="n">⟩</span>
</code></pre></div>

<p>Give the responses both when the evaluator memoizes and when it does not.</p>
<h5>Solution</h5>
<h4 id="exercise-430">Exercise 4.30</h4>
<p>Cy D. Fect, a reformed C
programmer, is worried that some side effects may never take place, because the
lazy evaluator doesn't force the expressions in a sequence.  Since the value of
an expression in a sequence other than the last one is not used (the expression
is there only for its effect, such as assigning to a variable or printing),
there can be no subsequent use of this value (e.g., as an argument to a
primitive procedure) that will cause it to be forced.  Cy thus thinks that when
evaluating sequences, we must force all expressions in the sequence except the
final one.  He proposes to modify <code>eval-sequence</code> from 4.1.1
to use <code>actual-value</code> rather than <code>eval</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">eval-sequence</span><span class="w"> </span><span class="n">exps</span><span class="w"> </span><span class="n">env</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="n">last-exp?</span><span class="w"> </span><span class="n">exps</span><span class="p">)</span><span class="w"> </span>
<span class="w">         </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="p">(</span><span class="n">first-exp</span><span class="w"> </span><span class="n">exps</span><span class="p">)</span><span class="w"> </span><span class="n">env</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">else</span><span class="w"> </span>
<span class="w">         </span><span class="p">(</span><span class="n">actual-value</span><span class="w"> </span><span class="p">(</span><span class="n">first-exp</span><span class="w"> </span><span class="n">exps</span><span class="p">)</span><span class="w"> </span>
<span class="w">                       </span><span class="n">env</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">eval-sequence</span><span class="w"> </span><span class="p">(</span><span class="n">rest-exps</span><span class="w"> </span><span class="n">exps</span><span class="p">)</span><span class="w"> </span>
<span class="w">                        </span><span class="n">env</span><span class="p">))))</span>
</code></pre></div>

<p><strong>1.</strong> Ben Bitdiddle thinks Cy is wrong.  He shows Cy the <code>for-each</code> procedure
described in Exercise 2.23, which gives an important example of a
sequence with side effects:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">for-each</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="ss">done</span>
<span class="w">      </span><span class="p">(</span><span class="k">begin</span><span class="w"> </span><span class="p">(</span><span class="n">proc</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">items</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nb">for-each</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span>
<span class="w">                       </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">items</span><span class="p">)))))</span>
</code></pre></div>

<p>He claims that the evaluator in the text (with the original
<code>eval-sequence</code>) handles this correctly:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; L-Eval input:</span>
<span class="p">(</span><span class="nb">for-each</span>
<span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">newline</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">57</span><span class="w"> </span><span class="mi">321</span><span class="w"> </span><span class="mi">88</span><span class="p">))</span>
<span class="mi">57</span>
<span class="mi">321</span>
<span class="mi">88</span>

<span class="c1">;;; L-Eval value:</span>
<span class="n">done</span>
</code></pre></div>

<p>Explain why Ben is right about the behavior of <code>for-each</code>.</p>
<p><strong>2.</strong> Cy agrees that Ben is right about the <code>for-each</code> example, but says that
that's not the kind of program he was thinking about when he proposed his
change to <code>eval-sequence</code>.  He defines the following two procedures in the
lazy evaluator:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">)))))</span>
</code></pre></div>

<p>What are the values of <code>(p1 1)</code> and <code>(p2 1)</code> with the original
<code>eval-sequence</code>?  What would the values be with Cy's proposed change to
<code>eval-sequence</code>?</p>
<p><strong>3.</strong> Cy also points out that changing <code>eval-sequence</code> as he proposes does not
affect the behavior of the example in part a.  Explain why this is true.</p>
<p><strong>4.</strong> How do you think sequences ought to be treated in the lazy evaluator?  Do you
like Cy's approach, the approach in the text, or some other approach?</p>
<h5>Solution</h5>
<h4 id="exercise-431">Exercise 4.31</h4>
<p>The approach taken in this
section is somewhat unpleasant, because it makes an incompatible change to
Scheme.  It might be nicer to implement lazy evaluation as an
upward-compatible extension, that is, so that ordinary Scheme
programs will work as before.  We can do this by extending the syntax of
procedure declarations to let the user control whether or not arguments are to
be delayed.  While we're at it, we may as well also give the user the choice
between delaying with and without memoization.  For example, the definition</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="k">lazy</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="n">lazy-memo</span><span class="p">))</span>
<span class="w">  </span><span class="n">@r</span><span class="p">{</span><span class="n">…</span><span class="p">})</span>
</code></pre></div>

<p>would define <code>f</code> to be a procedure of four arguments, where the first and
third arguments are evaluated when the procedure is called, the second argument
is delayed, and the fourth argument is both delayed and memoized.  Thus,
ordinary procedure definitions will produce the same behavior as ordinary
Scheme, while adding the <code>lazy-memo</code> declaration to each parameter of
every compound procedure will produce the behavior of the lazy evaluator
defined in this section. Design and implement the changes required to produce
such an extension to Scheme.  You will have to implement new syntax procedures
to handle the new syntax for <code>define</code>.  You must also arrange for
<code>eval</code> or <code>apply</code> to determine when arguments are to be delayed, and
to force or delay arguments accordingly, and you must arrange for forcing to
memoize or not, as appropriate.</p>
<h5>Solution</h5>
<h4 id="exercise-432">Exercise 4.32</h4>
<p>Give some examples that
illustrate the difference between the streams of Chapter 3 and the
``lazier'' lazy lists described in this section.  How can you take advantage of
this extra laziness?</p>
<h5>Solution</h5>
<h4 id="exercise-433">Exercise 4.33</h4>
<p>Ben Bitdiddle tests the lazy list
implementation given above by evaluating the expression</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">))</span>
</code></pre></div>

<p>To his surprise, this produces an error.  After some thought, he realizes that
the <code>`lists'' obtained by reading in quoted expressions are different from the
lists manipulated by the new definitions of</code>cons<code>,</code>car<code>, and</code>cdr`.  Modify the evaluator's treatment of quoted expressions so that
quoted lists typed at the driver loop will produce true lazy lists.</p>
<h5>Solution</h5>
<h4 id="exercise-434">Exercise 4.34</h4>
<p>Modify the driver loop for the
evaluator so that lazy pairs and lists will print in some reasonable way.
(What are you going to do about infinite lists?)  You may also need to modify
the representation of lazy pairs so that the evaluator can identify them in
order to print them.</p>
<h5>Solution</h5>
    </div>
</body>
</html>
